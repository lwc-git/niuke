1.Redis是什么
    redis是一种支持Key-Value等多种数据结构的存储系统。
    可用于缓存，事件发布或订阅，高速队列等场景。
    该数据库使用ANSI C语言编写，支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

2.redis应用场景有哪些
    1.会话缓存
    2.消息队列
    3.活动排行榜或计数
    4.发布订阅消息
    5.商品列表，评论列表等

3.redis数据类型
    Redis一共支持五种数据类：string，hash，list，set，zset
    zset （sorted set 有序集合）
    是string类型的有序集合，同样不可重复，这也是与list的区别之一
    有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序，所以sorted set非常适合用来作为排名

4.redis的发布与订阅
    redis的发布订阅是他的一种消息通信模式，一方发送消息，一方接收信息
    create a channel 然后由订阅者订阅

5.redis的持久化
    redis持久有两种方式：快照，仅附加文件（AOF）
    快照：将存储在内存的数据以快照的方式写入二进制文件中，如默认dump.rdb
    保存900 1
    如果在900秒内超过1个key被修改，则启动快照保存
    可以手动保存 save and bgsave bgsave会开启一个新的“进程”

    仅附加文件AOF
    使用aof持久时，服务会将每个收到写命令通过写函数追加到文件中
    appendonly yes
    appendfsync always 立即写入
    appendfsync everysec 每秒写入一次
    appendfsync no 完全依赖操作系统

6.redis的缺点
    1.缓存和数据库双写一致性问题
    2.缓存雪崩问题
    3.缓存击穿问题
    4.缓存的并发竞争问题

7.redis优点主要从性能和并发两方面考虑 *
    1.性能：如果碰见一些耗时很久，但是结果不频繁变动的SQL，就适合将结果放入缓存。
    这样后面的请求就去缓存中读取，使得请求能够迅速响应
    迅速响应的标准：（玩笑）在理想状态下，页面跳转需要在瞬间解决，对于页面内操作则需要在刹那间解决。
    另外，超过一弹指的耗时操作需要有进度提示，并且随时中止或取消，这样才能给用户最好的体验。
    一瞬间0.36s 一刹那0.018s 一弹指长达7.2秒
    2.并发：在并发情况下，所有的请求直接访问数据库，数据库会出现连接异常，这个时候就需要使用
    redis做一个缓冲操作，让请求先访问redis，而不是访问数据库

8.单线程的redis为什么这么快
    1.纯内存操作
    2.单线程操作，避免了频繁的上下文切换
    3.采用了非阻塞的i/o多路复用机制
    现在要仔细的说一说I/O多路复用机制.下面用一个例子来说明：
    小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。

    经营方式一
    客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题
    1.几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递
    2.随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了
    3.快递员之间的协调很花时间

    经营方式二
    小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。
    最后，那个快递员依次的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。

    快递员-每个线程  快递-每个io流 快递地点-每个socket的不同状态 客户送快递请求-客户请求
    小曲的经营方式-服务端运行的代码 一辆车-cpu核数

    于是我们有如下结论
    1.经营方式一就是传统的并发模型，每个io流都有一个新的线程管理
    2.经营方式二就是io多路复用，只有一个线程通过跟踪每个io流的状态来管理多个io流

    具体到redis：就是在redis-client在操作的时候会产生不同事件类型的socket，在服务端有一段io多路
    复用程序，将其置入队列之中，然后文件事件分派器，依次去队列中取，转发到不同的事件处理器中。

9.redis的过期策略以及内存淘汰机制
    redis采用的是定期删除+惰性删除策略
    定时删除：时间一到就自动删除，虽然内存及时释放，但是十分消耗cpu资源，在大并发请求下，cpu
    要将时间应用在处理请求，而不是删除key，因此没有采用这一策略

    定期删除：redis默认每100ms检查，是否有过期key，有就删除，redis并不是每100ms都全部检查
    只是随机抽取检查。如果只采用定期删除策略，就会导致很多key到时间没有删除。

    惰性删除：在你获取某个key的时候，redis会检查下，这个key如果设置过期时间的话，如果过期就删除

    如果定期删除没有删除，你也没有去请求，那么惰性删除也没有生效，那么redis内存会越来越高
    这样就会采用内存淘汰机制，就需要取redis配置文件去配置，通常采用的策略是最近最少使用key

10.redis和数据库双写一致性问题
    一致性是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致问题。
    如果数据有强一致性要求，那么就不能放缓存。我们所作的一切都只能保证最终一致性。
    采用正确的更新策略，先更新数据库，再删除缓存，其次，因为可能存在删除缓存失败的问题，所以需要提供一个
    补偿措施，例如利用消息队列。

11.如果应用缓存穿透和缓存雪崩问题
    缓存穿透：黑客故意请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常
    解决方案
    1.利用互斥锁，缓存失效的时候先去获得锁再去请求数据库，没得到锁的休眠一段时间重试
    2.才用异步更新策略，无论key是否取值成功，value值中维护一个缓存失效时间，缓存如果过期，异步一个
    线程去读数据库，更新缓存。需要做缓存预热，项目启动前先加载缓存。
    3.提供一个能迅速判断请求是否有效的拦截机制。

    缓存雪崩：即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都都怼到数据库上，导致数据库连接异常
    解决方案
    1.给缓存的失效时间加上一个随机值，避免集体失效。
    2.使用互斥锁，但是该方案吞吐量明显下降了
    3.双缓存，我们有两个缓存，缓存ab，然后a缓存失效时间为20分钟，缓存b不设置失效时间，自己做缓存预热操作
        1.从缓存a读取数据库，有直接返回
        2.a没有数据，直接从b读数据，直接返回，并且异步启动一个更新线程
        3，更新线程同时更新缓存a和缓存b

12.如何解决redis的并发竞争key问题
    问题：如果有多个子系统去set一个key，这个时候要注意什么呢。基本上用redis事务机制。
    因为我们生产环境都是用reids集群环境，做了数据分片操作。所以事务机制十分鸡肋。
    1.如果对key操作不要求顺序，则可以准备一个分布式锁，谁抢到锁谁就做set操作
    2.如果对key操作要求顺序 则可以对每个value设置一个时间戳，具体可以使用zset

13.为什么redis是单线程的
   因为redis是基于内存的操作，cpu不是瓶颈，然后顺利成章的采用单线程方案了。

















































































